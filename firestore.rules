rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * CAMPUSLIBRO SECURITY RULES DOCUMENTATION
     *
     * Core Philosophy:
     * This ruleset implements a Hybrid Role-Based and Ownership-Based Access Control model. 
     * It leverages Database Access Control (DBAC) through dedicated roles collections to 
     * maintain "Authorization Independence," allowing roles to be checked without 
     * traversing complex document hierarchies.
     *
     * Data Structure:
     * - /users/{userId}: User profiles, owned by the user.
     * - /roles_librarian/{userId}: Marker collection; existence grants Librarian privileges.
     * - /roles_admin/{userId}: Marker collection; existence grants Admin privileges.
     * - /books/{bookId}: Public catalog of book metadata.
     * - /book_copies/{bookCopyId}: Public inventory of physical copies.
     * - /loans/{loanId}: Transactional records of borrowings.
     *
     * Key Security Decisions:
     * 1. Public Read/Staff Write: Books and BookCopies are publicly readable to allow 
     *    browsing, but only Librarians or Admins can modify the catalog or inventory.
     * 2. Denormalized Authorization: Loans contain a 'userId' field. This allows users 
     *    to list their own loans via Query as Authorization Policy (QAP) without 
     *    performing cross-document lookups.
     * 3. Role Hierarchy: Admins have full override capabilities. Librarians have 
     *    elevated access to library management (books, copies, loans) but limited 
     *    access to system-wide administrative roles.
     * 4. Self-Provisioning: Authenticated users can create their own profile in 
     *    the /users collection to ensure a smooth onboarding/login flow.
     */

    // --- GLOBAL HELPER FUNCTIONS ---

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    function isLibrarian() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_librarian/$(request.auth.uid));
    }

    function canManageLibrary() {
      return isAdmin() || isLibrarian();
    }

    // --- COLLECTION RULES ---

    /**
     * @description Rules for user profiles. Users can manage their own data; staff can view profiles.
     * @path /users/{userId}
     * @allow (create) if the user is authenticated and the doc ID matches their UID.
     * @deny (update) if the user attempts to change someone else's profile.
     * @principle Ownership-based access for users, role-based for management.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || canManageLibrary();
      allow list: if canManageLibrary(); // Users should only list their own, if needed, which can be done via QAP on a specific field. Listing all users is a staff function.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if resource != null && isOwner(userId) && request.resource.data.id == userId;
      allow delete: if isAdmin();
    }

    /**
     * @description System administrative roles. Only admins can assign other admins.
     * @path /roles_admin/{userId}
     * @allow (get) if signed in (to check one's own role).
     * @deny (write) if a non-admin tries to promote themselves.
     * @principle Database Access Control (DBAC) for system-wide permissions.
     */
    match /roles_admin/{userId} {
      allow get: if isSignedIn();
      allow list: if isAdmin();
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Librarian roles. Only admins can assign librarians.
     * @path /roles_librarian/{userId}
     * @allow (get) if signed in.
     * @deny (list) for standard users.
     * @principle DBAC for functional library management staff.
     */
    match /roles_librarian/{userId} {
      allow get: if isSignedIn();
      allow list: if canManageLibrary();
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description The public book catalog. Readable by all, writable by staff.
     * @path /books/{bookId}
     * @allow (get, list) for any user (public catalog).
     * @deny (create, update) for standard students/borrowers.
     * @principle Public read with role-restricted writes for shared resources.
     */
    match /books/{bookId} {
      allow get, list: if true;
      allow create: if canManageLibrary() && request.resource.data.id == bookId;
      allow update: if resource != null && canManageLibrary() && request.resource.data.id == bookId;
      allow delete: if canManageLibrary();
    }

    /**
     * @description Physical book copy inventory. Publicly checkable status.
     * @path /book_copies/{bookCopyId}
     * @allow (get, list) for everyone to check availability.
     * @deny (update) if a student tries to mark a book as 'Available'.
     * @principle Public inventory visibility with authoritative staff control.
     */
    match /book_copies/{bookCopyId} {
      allow get, list: if true;
      allow create: if canManageLibrary() && request.resource.data.id == bookCopyId;
      allow update: if resource != null && canManageLibrary() && request.resource.data.id == bookCopyId;
      allow delete: if canManageLibrary();
    }

    /**
     * @description Loan records for book checkouts. Users can see their own; staff manages all.
     * @path /loans/{loanId}
     * @allow (list) for users where userId matches their UID (using QAP).
     * @deny (create) if the userId in data doesn't match the authenticated user.
     * @principle Authorization Independence using denormalized 'userId' field.
     */
    match /loans/{loanId} {
      allow get: if canManageLibrary() || (isSignedIn() && resource.data.userId == request.auth.uid);
      // For list operations, the query itself must filter by userId.
      // This rule only allows listing if a user can manage the library or if they are performing a query filtered by their own UID.
      // Firestore does not allow `list` to check `resource.data` because it applies to a collection, not a specific document.
      // The `list` check for `isSignedIn() && resource.data.userId == request.auth.uid` would fail at query time.
      // A more appropriate approach for QAP is to ensure the query is properly constrained by the client.
      // However, for strict security, if a `list` is not *always* allowed (e.g., `canManageLibrary()`), 
      // then a user typically cannot `list` arbitrary documents without specific query constraints enforced by the rules.
      // Since the prompt is for "highly secure", disallowing general list for non-staff is safer.
      allow list: if canManageLibrary(); 
      // User-specific queries should be handled on the client side, then validated by the 'get' rule for individual documents.
      // Or, if truly needed, the list rule could be adjusted if there's a specific, verifiable query constraint in request.query.
      // For now, only staff can list all loans.
      
      allow create: if isSignedIn() && (request.resource.data.userId == request.auth.uid || canManageLibrary()) && request.resource.data.id == loanId;
      allow update: if resource != null && canManageLibrary();
      allow delete: if resource != null && isAdmin();
    }
  }
}